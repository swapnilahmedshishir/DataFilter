ডাটা স্ট্রাকচার আর এলগরিদম এর কমপ্লিট গাইডলাইন || Data Structure and algorithm Tutorial || Learn DSA

প্রথমেই যে ৭ ধরণের ডাটা স্ট্রাকচার আমাদের শিখতেই হবে: 
১) Arrays.
২) Linked Lists
৩) Stack 
৪) Queue
৫)Hash Tables বা Hash Map বা Dictionary: 
৬) Tree:
৭) Graphs
------------ 
যে ৭ ধরনের এলগরিদম আমাদের শিখতে হবে: 
১) Searching Algorithms
২) Sorting Algorithms
৩) টাইম আর স্পেস কমপ্লেক্সিটি
৪)  Divide and Conquer Algorithms এর মধ্যে বাইনারি সার্চ, মার্জ শর্ট অন্যতম। 
৫) Dynamic programming (DP)
৬) Tree রিলেটেড এলগরিদম
৭) Graph রিলেটেড এলগরিদম
React course Anisul islam 


Complete Guidelines for Data Structures and Algorithms 

First we need to learn the 7 types of data structures:
1) Arrays.
2) Linked Lists
3) Stack
4) Queue
5) Hash Tables or Hash Map or Dictionary:
6) Tree:
7) Graphs
------------
The 7 types of algorithms we need to learn are:
1) Searching Algorithms
2) Sorting Algorithms
3) Time and Space Complexity
4) Divide and Conquer Algorithms include Binary Search, Merge Short.
5) Dynamic programming (DP)
6) Tree related algorithm
7) Graph related algorithm



Complete Guidelines for Data Structures and Algorithms 

First we need to learn the 7 types of data structures:
1. Arrays:

   - An ordered collection of elements, each identified by an index or a key.

   - Elements are stored in contiguous memory locations.

   - Fast access to elements using their index.

2. Linked Lists:

   - A linear data structure consisting of nodes, where each node points to the next node in the sequence.

   - Dynamic size, easy insertion, and deletion of elements.

3. Stacks:

   - A last-in, first-out (LIFO) data structure.

   - Elements are added and removed from the same end, known as the "top" of the stack.

4. Queues:

   - A first-in, first-out (FIFO) data structure.

   - Elements are added at the rear (enqueue) and removed from the front (dequeue) of the queue.

5. Trees:

   - A hierarchical data structure with a root node and child nodes.

   - Binary Trees: Each node has at most two children.

   - Binary Search Trees (BST): A binary tree where the left child is smaller than the parent, and the right child is larger.

6. Graphs:

   - A collection of nodes (vertices) connected by edges.

   - Directed Graphs: Edges have a direction.

   - Undirected Graphs: Edges do not have a direction.

7. Hash Tables:

   - A data structure that maps keys to values using a hash function.

   - Provides efficient insertion, deletion, and retrieval of data.

   - Addresses the problem of collision through techniques like chaining or open addressing.



Understanding these data structures is crucial for designing algorithms and solving various computational problems efficiently. Each type has its strengths and weaknesses, and the choice of data structure depends on the specific requirements of the task at hand.


The 7 types of algorithms we need to learn are:
1. Sorting Algorithms:

   - Sorting algorithms arrange elements in a specific order, such as ascending or descending.

   - Examples include Bubble Sort, Insertion Sort, Merge Sort, and Quick Sort.

2. Searching Algorithms:

   - Searching algorithms find the presence, location, or occurrence of a target value within a collection of data.

   - Examples include Linear Search and Binary Search.

3. Graph Algorithms:

   - Graph algorithms operate on graphs (collections of nodes and edges) to solve problems like finding the shortest path, detecting cycles, or determining connectivity.

   - Examples include Dijkstra's algorithm for shortest paths and Depth-First Search (DFS) for traversal.

4. Divide and Conquer Algorithms:

   - Divide and Conquer algorithms solve a problem by breaking it down into smaller subproblems, solving them recursively, and then combining the solutions to solve the original problem.

   - Examples include Merge Sort and Quick Sort.

5. Dynamic Programming Algorithms:

   - Dynamic Programming algorithms solve problems by breaking them down into overlapping subproblems and solving each subproblem only once, storing the results for future use.

   - Examples include the Knapsack problem and the Fibonacci sequence.

6. Greedy Algorithms:

   - Greedy algorithms make locally optimal choices at each stage with the hope of finding a global optimum.

   - Examples include Dijkstra's algorithm for finding the shortest path and Huffman coding for data compression.

7. Backtracking Algorithms:

   - Backtracking algorithms solve problems incrementally, trying different options at each decision point and undoing their choices if they lead to an invalid solution.

   - Examples include the N-Queens problem and the Sudoku solver.



These algorithmic paradigms are foundational in computer science and are used to solve a wide range of computational problems. Understanding these algorithms provides a solid basis for designing efficient solutions to various challenges in programming and computer science.